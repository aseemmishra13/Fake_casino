<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fair Roulette Simulator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050816;
      --bg-alt: #0b1020;
      --card: #111827;
      --accent: #10b981;
      --accent-soft: rgba(16,185,129,0.1);
      --text: #f9fafb;
      --muted: #9ca3af;
      --danger: #f87171;
      --border: #1f2937;
      --shadow-soft: 0 18px 45px rgba(0,0,0,0.4);
      --radius-lg: 18px;
      --radius-xl: 24px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%, #000 100%);
      color: var(--text);
      display: flex;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .app {
      max-width: 1000px;
      width: 100%;
      background: linear-gradient(145deg, rgba(15,23,42,0.98), rgba(15,23,42,0.9));
      border-radius: 28px;
      padding: 24px 26px 26px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(148,163,184,0.2);
      backdrop-filter: blur(18px);
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(0, 2.2fr);
      gap: 20px;
    }

    @media (max-width: 820px) {
      .app {
        grid-template-columns: 1fr;
        padding: 18px 16px 20px;
      }
    }

    .header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      gap: 12px;
    }

    .title {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.03em;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .pill {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      background: rgba(15,23,42,0.9);
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid rgba(148,163,184,0.3);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .pill-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(16,185,129,0.9);
    }

    .balance-card {
      background: radial-gradient(circle at top, #022c22 0, #052e16 40%, #020617 100%);
      border-radius: 18px;
      padding: 12px 16px;
      border: 1px solid rgba(52,211,153,0.5);
      box-shadow: 0 12px 30px rgba(16,185,129,0.35);
      min-width: 210px;
    }

    .balance-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      color: rgba(190,242,100,0.9);
      margin-bottom: 4px;
    }

    .balance-value {
      font-size: 22px;
      font-weight: 600;
      display: flex;
      align-items: baseline;
      gap: 4px;
    }

    .balance-value span {
      font-size: 12px;
      color: rgba(248,250,252,0.7);
      font-weight: 400;
    }

    .balance-change {
      font-size: 11px;
      margin-top: 2px;
    }

    .balance-change.positive {
      color: #4ade80;
    }

    .balance-change.negative {
      color: #f97373;
    }

    .card {
      background: radial-gradient(circle at top left, #111827 0, #020617 70%);
      border-radius: var(--radius-lg);
      padding: 14px 15px 15px;
      border: 1px solid var(--border);
      box-shadow: 0 12px 32px rgba(15,23,42,0.8);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }

    .card-title {
      font-size: 12px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .tag {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.3);
      color: rgba(148,163,184,0.9);
    }

    .layout-left {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .layout-right {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    /* Wheel + result display */
    .wheel-section {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .wheel {
      position: relative;
      border-radius: var(--radius-xl);
      background: radial-gradient(circle at center, #020617 0, #020617 40%, #000 100%);
      padding: 20px 18px 18px;
      border: 1px solid rgba(148,163,184,0.25);
      overflow: visible;
      min-height: 320px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .wheel-visual {
      flex-shrink: 0;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 210px;
    }

    .wheel-inner {
      width: 180px;
      height: 180px;
      border-radius: 999px;
      position: relative;
      background: conic-gradient(
        #b91c1c 0deg 9.73deg,
        #111827 9.73deg 19.46deg,
        #b91c1c 19.46deg 29.19deg,
        #111827 29.19deg 38.92deg,
        #b91c1c 38.92deg 48.65deg,
        #111827 48.65deg 58.38deg,
        #b91c1c 58.38deg 68.11deg,
        #111827 68.11deg 77.84deg,
        #b91c1c 77.84deg 87.57deg,
        #111827 87.57deg 97.3deg,
        #b91c1c 97.3deg 107.03deg,
        #111827 107.03deg 116.76deg,
        #b91c1c 116.76deg 126.49deg,
        #111827 126.49deg 136.22deg,
        #b91c1c 136.22deg 145.95deg,
        #111827 145.95deg 155.68deg,
        #b91c1c 155.68deg 165.41deg,
        #111827 165.41deg 175.14deg,
        #b91c1c 175.14deg 184.87deg,
        #111827 184.87deg 194.6deg,
        #b91c1c 194.6deg 204.33deg,
        #111827 204.33deg 214.06deg,
        #b91c1c 214.06deg 223.79deg,
        #111827 223.79deg 233.52deg,
        #b91c1c 233.52deg 243.25deg,
        #111827 243.25deg 252.98deg,
        #b91c1c 252.98deg 262.71deg,
        #111827 262.71deg 272.44deg,
        #b91c1c 272.44deg 282.17deg,
        #111827 282.17deg 291.9deg,
        #b91c1c 291.9deg 301.63deg,
        #111827 301.63deg 311.36deg,
        #b91c1c 311.36deg 321.09deg,
        #111827 321.09deg 330.82deg,
        #b91c1c 330.82deg 340.55deg,
        #111827 340.55deg 350.28deg,
        #b91c1c 350.28deg 360deg
      );
      border: 6px solid #020617;
      box-shadow:
        0 0 30px rgba(15,23,42,0.8),
        inset 0 0 12px rgba(15,15,15,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wheel-center {
      width: 70px;
      height: 70px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #facc15, #b45309);
      box-shadow:
        0 0 18px rgba(234,179,8,0.7),
        inset 0 0 8px rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #1f2937;
      font-weight: 700;
      font-size: 26px;
    }

    .pointer {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 16px solid #facc15;
      filter: drop-shadow(0 0 6px rgba(234,179,8,0.9));
    }

    .wheel-info {
      margin-top: 14px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 2px;
      flex-shrink: 0;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
      margin-top: 6px;
      color: rgba(148,163,184,0.95);
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34,197,94,0.9);
    }

    /* Bet form */
    .bet-form {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 3px;
      font-size: 12px;
    }

    .field label {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.11em;
    }

    select, input[type="number"], input[type="text"] {
      padding: 7px 9px;
      border-radius: 9px;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.95);
      color: var(--text);
      font-size: 13px;
      outline: none;
      transition: border-color 0.16s ease, box-shadow 0.16s ease, background 0.2s ease;
    }

    select:focus,
    input[type="number"]:focus,
    input[type="text"]:focus {
      border-color: rgba(45,212,191,0.7);
      box-shadow: 0 0 0 1px rgba(45,212,191,0.5);
      background: rgba(15,23,42,1);
    }

    .input-row {
      display: flex;
      gap: 8px;
    }

    .input-row > * {
      flex: 1;
    }

    .hint {
      font-size: 11px;
      color: var(--muted);
    }

    .actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 4px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.2s ease, opacity 0.2s ease;
      white-space: nowrap;
    }

    .btn-primary {
      background: linear-gradient(135deg, #22c55e, #14b8a6);
      color: #022c22;
      box-shadow:
        0 12px 28px rgba(34,197,94,0.4),
        0 0 10px rgba(34,197,94,0.5);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow:
        0 18px 38px rgba(34,197,94,0.55),
        0 0 16px rgba(34,197,94,0.7);
    }

    .btn-primary:active {
      transform: translateY(0);
      box-shadow:
        0 10px 24px rgba(34,197,94,0.4),
        0 0 12px rgba(34,197,94,0.5);
    }

    .btn-secondary {
      background: rgba(15,23,42,0.9);
      color: rgba(148,163,184,0.95);
      border: 1px solid rgba(148,163,184,0.45);
    }

    .btn-secondary:hover {
      background: rgba(15,23,42,1);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    .error {
      font-size: 11px;
      color: var(--danger);
      margin-top: 2px;
      min-height: 14px;
    }

    /* Latest result */
    .latest-result {
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 13px;
    }

    .result-number {
      font-size: 28px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .chip {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.95);
      color: rgba(209,213,219,0.95);
    }

    .chip-win {
      border-color: rgba(52,211,153,0.7);
      background: rgba(21,128,61,0.35);
      color: #bbf7d0;
    }

    .chip-loss {
      border-color: rgba(248,113,113,0.7);
      background: rgba(127,29,29,0.35);
      color: #fecaca;
    }

    .result-details {
      font-size: 12px;
      color: var(--muted);
    }

    /* History */
    .history-list {
      margin-top: 4px;
      max-height: 190px;
      overflow-y: auto;
      padding-right: 2px;
    }

    .history-item {
      display: grid;
      grid-template-columns: 52px 1.2fr 1fr;
      gap: 6px;
      align-items: center;
      font-size: 11px;
      padding: 4px 6px;
      border-radius: 9px;
      background: rgba(15,23,42,0.8);
      border: 1px solid rgba(30,64,175,0.5);
      margin-bottom: 4px;
    }

    .history-item:nth-child(even) {
      background: rgba(17,24,39,0.9);
    }

    .number-pill {
      padding: 3px 6px;
      border-radius: 999px;
      font-weight: 600;
      text-align: center;
      min-width: 38px;
    }

    .number-red {
      background: rgba(220,38,38,0.2);
      border: 1px solid rgba(248,113,113,0.7);
      color: #fecaca;
    }

    .number-black {
      background: rgba(15,23,42,0.8);
      border: 1px solid rgba(148,163,184,0.7);
      color: #e5e7eb;
    }

    .number-green {
      background: rgba(22,163,74,0.3);
      border: 1px solid rgba(74,222,128,0.8);
      color: #bbf7d0;
    }

    .hist-meta {
      color: var(--muted);
    }

    .hist-win {
      color: #4ade80;
      font-weight: 500;
    }

    .hist-loss {
      color: #f97373;
      font-weight: 500;
    }

    /* Stats */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 8px;
      font-size: 11px;
    }

    .stat-block {
      background: rgba(15,23,42,0.9);
      border-radius: 12px;
      padding: 6px 8px;
      border: 1px solid rgba(51,65,85,0.9);
    }

    .stat-label {
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.11em;
      font-size: 10px;
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 14px;
      font-weight: 500;
    }

    .stat-sub {
      font-size: 10px;
      color: var(--muted);
      margin-top: 1px;
    }

    /* Roulette Table */
    .table-container {
      background: radial-gradient(circle at top, #0a3d2e 0, #052e16 40%, #020617 100%);
      border-radius: var(--radius-lg);
      padding: 16px;
      border: 2px solid rgba(52,211,153,0.4);
      overflow-x: auto;
    }

    .roulette-table {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 6px;
      min-width: 600px;
      margin: 0 auto;
    }

    .table-main {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 3px;
    }

    .bet-cell {
      aspect-ratio: 1.3 / 1;
      border: 2px solid rgba(148,163,184,0.4);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      user-select: none;
    }

    .bet-cell:hover {
      transform: scale(1.05);
      border-color: rgba(52,211,153,0.9);
      box-shadow: 0 0 15px rgba(52,211,153,0.5);
    }

    .bet-cell.active {
      box-shadow: 0 0 20px rgba(52,211,153,0.8);
      border-color: #22c55e;
    }

    .number-cell {
      background: linear-gradient(135deg, rgba(17,24,39,0.9), rgba(30,41,59,0.9));
      color: #e5e7eb;
    }

    .number-cell.red {
      background: linear-gradient(135deg, #b91c1c, #991b1b);
      color: #fef2f2;
    }

    .number-cell.green {
      background: linear-gradient(135deg, #16a34a, #15803d);
      color: #f0fdf4;
    }

    .outside-bet {
      background: linear-gradient(135deg, rgba(15,23,42,0.95), rgba(30,41,59,0.95));
      border: 2px solid rgba(148,163,184,0.5);
      padding: 8px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s ease;
      color: #e5e7eb;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .outside-bet:hover {
      transform: scale(1.03);
      border-color: rgba(52,211,153,0.9);
      box-shadow: 0 0 15px rgba(52,211,153,0.4);
    }

    .outside-bet.active {
      box-shadow: 0 0 20px rgba(52,211,153,0.8);
      border-color: #22c55e;
      background: linear-gradient(135deg, rgba(22,163,74,0.3), rgba(21,128,61,0.3));
    }

    .table-side {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .column-bet {
      flex: 1;
      background: linear-gradient(135deg, rgba(15,23,42,0.95), rgba(30,41,59,0.95));
      border: 2px solid rgba(148,163,184,0.5);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
      color: #e5e7eb;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      padding: 4px;
    }

    .column-bet:hover {
      transform: scale(1.03);
      border-color: rgba(52,211,153,0.9);
      box-shadow: 0 0 15px rgba(52,211,153,0.4);
    }

    .column-bet.active {
      box-shadow: 0 0 20px rgba(52,211,153,0.8);
      border-color: #22c55e;
      background: linear-gradient(135deg, rgba(22,163,74,0.3), rgba(21,128,61,0.3));
    }

    .outside-bets-row {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      margin-top: 10px;
    }

    .chip-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      background: #facc15;
      color: #1f2937;
      border-radius: 999px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 700;
      box-shadow: 0 2px 8px rgba(234,179,8,0.6);
    }

    .current-bets {
      margin-top: 12px;
      padding: 10px;
      background: rgba(15,23,42,0.6);
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,0.3);
    }

    .current-bets-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .bet-chips-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .bet-chip {
      background: rgba(30,41,59,0.9);
      border: 1px solid rgba(148,163,184,0.4);
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bet-chip-remove {
      cursor: pointer;
      color: #f87171;
      font-weight: 700;
      transition: color 0.15s ease;
    }

    .bet-chip-remove:hover {
      color: #ef4444;
    }

    .table-controls {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .chip-selector {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .chip-btn {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 3px solid;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .chip-btn:hover {
      transform: scale(1.1);
    }

    .chip-btn.selected {
      box-shadow: 0 0 20px currentColor;
      transform: scale(1.15);
    }

    .chip-1 {
      background: #f3f4f6;
      border-color: #9ca3af;
      color: #1f2937;
    }

    .chip-5 {
      background: #ef4444;
      border-color: #dc2626;
      color: #fef2f2;
    }

    .chip-10 {
      background: #3b82f6;
      border-color: #2563eb;
      color: #eff6ff;
    }

    .chip-25 {
      background: #16a34a;
      border-color: #15803d;
      color: #f0fdf4;
    }

    .chip-100 {
      background: #1f2937;
      border-color: #facc15;
      color: #facc15;
    }

    .strategy-simulator {
      grid-column: 1 / -1;
      background: radial-gradient(circle at top left, #1e1b4b 0, #0f172a 70%);
      border: 2px solid rgba(139,92,246,0.4);
    }

    .sim-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .sim-actions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .btn-sim {
      background: linear-gradient(135deg, #8b5cf6, #6366f1);
      color: white;
      box-shadow: 0 12px 28px rgba(139,92,246,0.4);
    }

    .btn-sim:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 38px rgba(139,92,246,0.55);
    }

    .sim-results {
      margin-top: 14px;
      padding: 12px;
      background: rgba(15,23,42,0.6);
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.3);
      display: none;
    }

    .sim-results.active {
      display: block;
    }

    .sim-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .sim-progress {
      margin-top: 8px;
      padding: 8px;
      background: rgba(15,23,42,0.8);
      border-radius: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(15,23,42,0.9);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 6px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #8b5cf6, #6366f1);
      border-radius: 999px;
      transition: width 0.2s ease;
    }

    .sim-chart {
      margin-top: 12px;
      height: 200px;
      background: rgba(15,23,42,0.9);
      border-radius: 8px;
      padding: 10px;
      position: relative;
    }

    .chart-line {
      stroke: #8b5cf6;
      stroke-width: 2;
      fill: none;
    }

    .chart-grid {
      stroke: rgba(148,163,184,0.2);
      stroke-width: 1;
    }

    .chart-label {
      font-size: 10px;
      fill: var(--muted);
    }

    .strategy-info {
      font-size: 11px;
      color: var(--muted);
      margin-top: 4px;
      padding: 6px 8px;
      background: rgba(139,92,246,0.1);
      border-radius: 6px;
      border: 1px solid rgba(139,92,246,0.3);
    }

    /* Blackjack Styles */
    .blackjack-section {
      grid-column: 1 / -1;
      background: radial-gradient(circle at top left, #1e3a1e 0, #0f172a 70%);
      border: 2px solid rgba(34,197,94,0.4);
      margin-top: 20px;
    }

    .bj-game-area {
      display: grid;
      grid-template-columns: 200px 1fr;
      gap: 16px;
      margin-top: 12px;
    }

    @media (max-width: 920px) {
      .bj-game-area {
        grid-template-columns: 1fr;
      }
    }

    .bj-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .bj-table {
      background: radial-gradient(ellipse at center, #0f4d2e 0%, #0a2818 70%);
      border-radius: 16px;
      padding: 20px;
      border: 3px solid rgba(34,197,94,0.5);
      min-height: 500px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .bj-dealer-area,
    .bj-players-area {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .bj-player {
      background: rgba(15,23,42,0.7);
      border-radius: 12px;
      padding: 12px;
      border: 2px solid rgba(148,163,184,0.3);
    }

    .bj-player.active {
      border-color: #22c55e;
      box-shadow: 0 0 20px rgba(34,197,94,0.4);
    }

    .bj-player.dealer {
      background: rgba(127,29,29,0.3);
      border-color: rgba(248,113,113,0.5);
    }

    .bj-player-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .bj-player-name {
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .bj-player-status {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.3);
    }

    .bj-player-status.win {
      background: rgba(34,197,94,0.3);
      border-color: rgba(34,197,94,0.7);
      color: #bbf7d0;
    }

    .bj-player-status.lose {
      background: rgba(239,68,68,0.3);
      border-color: rgba(239,68,68,0.7);
      color: #fecaca;
    }

    .bj-player-status.push {
      background: rgba(234,179,8,0.3);
      border-color: rgba(234,179,8,0.7);
      color: #fef3c7;
    }

    .bj-player-status.blackjack {
      background: linear-gradient(135deg, #facc15, #f59e0b);
      border-color: #f59e0b;
      color: #1f2937;
      font-weight: 700;
    }

    .bj-cards {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .bj-card {
      width: 60px;
      height: 84px;
      background: white;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      padding: 6px 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-weight: 700;
      position: relative;
      font-size: 18px;
    }

    .bj-card.red {
      color: #dc2626;
    }

    .bj-card.black {
      color: #1f2937;
    }

    .bj-card.hidden {
      background: linear-gradient(135deg, #1e40af, #7c3aed);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-value {
      font-size: 16px;
      font-weight: 700;
    }

    .card-suit {
      font-size: 24px;
    }

    .bj-hand-value {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .bj-hand-value strong {
      color: var(--text);
      font-size: 16px;
    }

    .bj-game-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .btn-bj {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
    }

    .btn-bj:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(34,197,94,0.4);
    }

    .btn-bj-alt {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
    }

    .bj-bet-info {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .bj-bet-info strong {
      color: #fbbf24;
    }

    .bj-deck-info {
      font-size: 11px;
      color: var(--muted);
      padding: 6px 10px;
      background: rgba(15,23,42,0.6);
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,0.2);
      margin-top: 8px;
    }

    .bj-strategy-feedback {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 12px;
      border: 2px solid;
      display: none;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .bj-strategy-feedback.correct {
      background: rgba(34,197,94,0.2);
      border-color: rgba(34,197,94,0.6);
      color: #bbf7d0;
    }

    .bj-strategy-feedback.incorrect {
      background: rgba(239,68,68,0.2);
      border-color: rgba(239,68,68,0.6);
      color: #fecaca;
    }

    .bj-strategy-feedback strong {
      font-weight: 700;
      color: white;
    }

    .bj-strategy-stats {
      margin-top: 8px;
      padding: 8px 10px;
      background: rgba(15,23,42,0.6);
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,0.2);
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .bj-strategy-stats .stat-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .bj-strategy-stats .stat-label {
      color: var(--muted);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .bj-strategy-stats .stat-value {
      font-weight: 600;
      font-size: 14px;
    }

    .bj-strategy-stats .stat-value.good {
      color: #4ade80;
    }

    .bj-strategy-stats .stat-value.bad {
      color: #f87171;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title">
        <div class="pill">
          <span class="pill-dot"></span>
          Fair Roulette Simulator ¬∑ Client-Side ¬∑ No Rigging
        </div>
        <h1>Roulette ¬∑ Pure Probability</h1>
      </div>
      <div class="balance-card" id="balance-card">
        <div class="balance-label">Virtual Bankroll</div>
        <div class="balance-value">
          $<span id="balance-value">1000</span>
          <span>chips</span>
        </div>
        <div id="balance-change" class="balance-change"></div>
      </div>
    </div>

    <!-- Left side -->
    <div class="layout-left">
      <div class="card">
        <div class="card-header">
          <div class="card-title">Wheel & Outcome</div>
          <span class="tag">American ¬∑ Double Zero</span>
        </div>
        <div class="wheel-section">
          <div class="wheel">
            <div class="wheel-visual">
              <div class="pointer"></div>
              <div class="wheel-inner" id="wheel-inner">
                <div class="wheel-center" id="wheel-center">?</div>
              </div>
            </div>
            <div class="wheel-info">
              <div class="info-row">
                <span>Numbers</span>
                <span>0, 00, 1 ‚Äì 36</span>
              </div>
              <div class="info-row">
                <span>House edge</span>
                <span>‚âà 5.26% (built into rules, not code)</span>
              </div>
              <div class="badge">
                <span class="badge-dot"></span>
                Randomness via <strong>crypto.getRandomValues</strong>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="card-title">Betting Table</div>
          <span class="tag">Click to place bets</span>
        </div>
        <div class="table-container">
          <div class="roulette-table" id="roulette-table">
            <!-- Table will be generated by JavaScript -->
          </div>
          
          <div class="table-controls">
            <div class="chip-selector">
              <div class="chip-btn chip-1 selected" data-value="1">$1</div>
              <div class="chip-btn chip-5" data-value="5">$5</div>
              <div class="chip-btn chip-10" data-value="10">$10</div>
              <div class="chip-btn chip-25" data-value="25">$25</div>
              <div class="chip-btn chip-100" data-value="100">$100</div>
            </div>
          </div>

          <div class="current-bets" id="current-bets-display">
            <div class="current-bets-title">Current Bets: $<span id="total-bet-amount">0</span></div>
            <div class="bet-chips-list" id="bet-chips-list"></div>
          </div>

          <div class="actions" style="margin-top: 12px;">
            <button class="btn btn-primary" id="spin-btn">
              üé∞ Spin ($<span id="spin-total">0</span>)
            </button>
            <button class="btn btn-secondary" id="repeat-bet-btn" disabled>
              üîÑ Repeat Last Bet
            </button>
            <button class="btn btn-secondary" id="clear-bets-btn">
              Clear Bets
            </button>
            <button class="btn btn-secondary" id="reset-btn">
              Reset Bankroll
            </button>
          </div>
          <div id="error" class="error"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="card-title">Latest Spin</div>
          <span class="tag">Result details</span>
        </div>
        <div class="latest-result" id="latest-result">
          <div class="result-number">
            ‚Äì
            <span class="chip">No spins yet</span>
          </div>
          <div class="result-details">
            Place a bet and hit ‚ÄúSpin‚Äù to begin.
          </div>
        </div>
      </div>
    </div>

    <!-- Right side -->
    <div class="layout-right">
      <div class="card">
        <div class="card-header">
          <div class="card-title">History (Last 20 Spins)</div>
          <span class="tag">Outcome ¬∑ Bet ¬∑ Payout</span>
        </div>
        <div class="history-list" id="history-list"></div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="card-title">Quick Stats</div>
          <span class="tag">Convergence over time</span>
        </div>
        <div class="stats-grid">
          <div class="stat-block">
            <div class="stat-label">Total spins</div>
            <div class="stat-value" id="stat-spins">0</div>
            <div class="stat-sub">The more spins, the closer to theoretical odds.</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Red / Black</div>
            <div class="stat-value">
              <span id="stat-red">0</span> /
              <span id="stat-black">0</span>
            </div>
            <div class="stat-sub">
              Excluding green zero.
            </div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Net profit</div>
            <div class="stat-value" id="stat-profit">$0</div>
            <div class="stat-sub">
              From starting bankroll of $1000.
            </div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Greens (0 & 00)</div>
            <div class="stat-value" id="stat-green">0</div>
            <div class="stat-sub">
              2 in 38 on average.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Strategy Simulator -->
    <div class="card strategy-simulator">
      <div class="card-header">
        <div class="card-title">üéØ Strategy Simulator</div>
        <span class="tag">Automated Testing</span>
      </div>
      
      <div class="sim-controls">
        <div class="field">
          <label>Strategy Type</label>
          <select id="strategy-type">
            <option value="flat">Flat Betting</option>
            <option value="martingale">Martingale</option>
            <option value="dual-martingale">Dual Martingale (2 Independent Bets)</option>
            <option value="reverse-martingale">Reverse Martingale</option>
            <option value="dalembert">D'Alembert</option>
            <option value="fibonacci">Fibonacci</option>
            <option value="labouchere">Labouchere</option>
            <option value="paroli">Paroli (1-3-2-6)</option>
          </select>
          <div id="strategy-info" class="strategy-info"></div>
        </div>

        <div class="field">
          <label>Bet Target <span id="bet-target-label"></span></label>
          <select id="sim-bet-target">
            <optgroup label="Even Money Bets (1:1)">
              <option value="red">Red</option>
              <option value="black">Black</option>
              <option value="odd">Odd</option>
              <option value="even">Even</option>
              <option value="low">Low (1-18)</option>
              <option value="high">High (19-36)</option>
            </optgroup>
            <optgroup label="2:1 Bets (Higher Risk/Reward)">
              <option value="dozen-1">1st Dozen (1-12)</option>
              <option value="dozen-2">2nd Dozen (13-24)</option>
              <option value="dozen-3">3rd Dozen (25-36)</option>
              <option value="column-1">Column 1 (1,4,7...34)</option>
              <option value="column-2">Column 2 (2,5,8...35)</option>
              <option value="column-3">Column 3 (3,6,9...36)</option>
            </optgroup>
            <optgroup label="Dual 2:1 Bets (Covers ~63%)" id="dual-bet-group" style="display:none;">
              <option value="dual-dozen-1-2">1st & 2nd Dozens</option>
              <option value="dual-dozen-1-3">1st & 3rd Dozens</option>
              <option value="dual-dozen-2-3">2nd & 3rd Dozens</option>
              <option value="dual-column-1-2">Columns 1 & 2</option>
              <option value="dual-column-1-3">Columns 1 & 3</option>
              <option value="dual-column-2-3">Columns 2 & 3</option>
            </optgroup>
          </select>
          <span class="hint" id="bet-odds-hint">Pays 1:1 (even money)</span>
        </div>

        <div class="field">
          <label>Initial Bet ($)</label>
          <input type="number" id="sim-initial-bet" value="10" min="1" max="100">
        </div>

        <div class="field">
          <label>Number of Rounds</label>
          <input type="number" id="sim-rounds" value="100" min="1" max="10000">
        </div>

        <div class="field">
          <label>Starting Bankroll ($)</label>
          <input type="number" id="sim-starting-balance" value="1000" min="100" max="100000">
        </div>

        <div class="field">
          <label>Max Bet Limit ($)</label>
          <input type="number" id="sim-max-bet" value="500" min="10" max="10000">
          <span class="hint">Prevents unlimited doubling</span>
        </div>
      </div>

      <div class="sim-actions">
        <button class="btn btn-sim" id="run-sim-btn">
          ‚ñ∂Ô∏è Run Simulation
        </button>
        <button class="btn btn-secondary" id="stop-sim-btn" disabled>
          ‚èπÔ∏è Stop
        </button>
        <button class="btn btn-secondary" id="clear-sim-btn">
          üóëÔ∏è Clear Results
        </button>
      </div>

      <div id="sim-progress" class="sim-progress" style="display: none;">
        <div>Progress: <span id="sim-progress-text">0 / 0</span></div>
        <div class="progress-bar">
          <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
      </div>

      <div id="sim-results" class="sim-results">
        <div class="current-bets-title">Simulation Results</div>
        <div class="sim-stats-grid">
          <div class="stat-block">
            <div class="stat-label">Final Balance</div>
            <div class="stat-value" id="sim-final-balance">$0</div>
            <div class="stat-sub" id="sim-profit-pct">0%</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Rounds Played</div>
            <div class="stat-value" id="sim-rounds-played">0</div>
            <div class="stat-sub">of <span id="sim-rounds-total">0</span></div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Win / Loss</div>
            <div class="stat-value"><span id="sim-wins">0</span> / <span id="sim-losses">0</span></div>
            <div class="stat-sub"><span id="sim-win-rate">0%</span> win rate</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Total Wagered</div>
            <div class="stat-value" id="sim-total-wagered">$0</div>
            <div class="stat-sub">Across all rounds</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Max Balance</div>
            <div class="stat-value" id="sim-max-balance">$0</div>
            <div class="stat-sub">Peak reached</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Max Drawdown</div>
            <div class="stat-value" id="sim-max-drawdown">$0</div>
            <div class="stat-sub">Lowest point</div>
          </div>
        </div>

        <div id="sim-chart" class="sim-chart">
          <svg id="balance-chart" width="100%" height="100%" viewBox="0 0 800 180">
            <line class="chart-grid" x1="0" y1="90" x2="800" y2="90" />
            <text class="chart-label" x="5" y="15">Balance Over Time</text>
            <polyline id="balance-line" class="chart-line" points="" />
          </svg>
        </div>
      </div>
    </div>

    <!-- Blackjack Game -->
    <div class="card blackjack-section">
      <div class="card-header">
        <div class="card-title">üÉè Blackjack</div>
        <span class="tag">Dealer stands on 17</span>
      </div>

      <div class="bj-game-area">
        <div class="bj-controls">
          <div class="field">
            <label>Number of Decks</label>
            <select id="bj-num-decks">
              <option value="1">1 Deck</option>
              <option value="2">2 Decks</option>
              <option value="4">4 Decks</option>
              <option value="6" selected>6 Decks</option>
              <option value="8">8 Decks</option>
            </select>
            <span class="hint" id="bj-deck-count">312 cards</span>
          </div>

          <div class="field">
            <label>AI Players</label>
            <select id="bj-num-players">
              <option value="0">Just You</option>
              <option value="1">1 AI Player</option>
              <option value="2" selected>2 AI Players</option>
              <option value="3">3 AI Players</option>
              <option value="4">4 AI Players</option>
              <option value="5">5 AI Players</option>
            </select>
          </div>

          <div class="field">
            <label>Your Bet ($)</label>
            <input type="number" id="bj-bet-amount" value="10" min="1" max="500">
          </div>

          <button class="btn btn-bj" id="bj-deal-btn">
            üé¥ Deal New Hand
          </button>

          <button class="btn btn-secondary" id="bj-reset-deck-btn">
            üîÑ Shuffle New Shoe
          </button>

          <div class="bj-deck-info">
            <div><strong>Cards Remaining:</strong> <span id="bj-cards-remaining">312</span></div>
            <div style="margin-top: 4px;"><strong>Penetration:</strong> <span id="bj-penetration">0%</span></div>
          </div>

          <div class="bj-strategy-stats">
            <div class="stat-item">
              <div class="stat-label">Correct</div>
              <div class="stat-value good" id="bj-correct-plays">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Incorrect</div>
              <div class="stat-value bad" id="bj-incorrect-plays">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Accuracy</div>
              <div class="stat-value" id="bj-accuracy">-</div>
            </div>
          </div>

          <div id="bj-strategy-feedback" class="bj-strategy-feedback"></div>
        </div>

        <div class="bj-table">
          <div class="bj-dealer-area">
            <div class="bj-player dealer" id="bj-dealer">
              <div class="bj-player-header">
                <div class="bj-player-name">üé© Dealer</div>
                <div class="bj-player-status" id="dealer-status"></div>
              </div>
              <div class="bj-cards" id="dealer-cards"></div>
              <div class="bj-hand-value" id="dealer-value"></div>
            </div>
          </div>

          <div class="bj-players-area" id="bj-players-area">
            <!-- Players will be generated here -->
          </div>

          <div class="bj-game-actions" id="bj-game-actions" style="display: none;">
            <button class="btn btn-bj" id="bj-hit-btn">üëä Hit</button>
            <button class="btn btn-bj-alt" id="bj-stand-btn">‚úã Stand</button>
            <button class="btn btn-secondary" id="bj-double-btn">2Ô∏è‚É£ Double Down</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- Blackjack Game State ---
    let bjDeck = [];
    let bjNumDecks = 6;
    let bjPlayers = [];
    let bjDealer = { cards: [], value: 0, busted: false };
    let bjCurrentPlayerIndex = -1;
    let bjGameInProgress = false;
    let bjPlayerBet = 10;
    let bjCorrectPlays = 0;
    let bjIncorrectPlays = 0;

    const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
    const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

    // --- Blackjack Functions ---
    function createDeck(numDecks) {
      const deck = [];
      for (let d = 0; d < numDecks; d++) {
        for (const suit of SUITS) {
          for (const value of VALUES) {
            deck.push({ value, suit });
          }
        }
      }
      return shuffleDeck(deck);
    }

    function shuffleDeck(deck) {
      const shuffled = [...deck];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const arr = new Uint32Array(1);
        crypto.getRandomValues(arr);
        const j = arr[0] % (i + 1);
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function getCardNumericValue(card) {
      if (card.value === 'A') return 11;
      if (['J', 'Q', 'K'].includes(card.value)) return 10;
      return parseInt(card.value);
    }

    function calculateHandValue(cards) {
      let value = 0;
      let aces = 0;

      for (const card of cards) {
        const cardValue = getCardNumericValue(card);
        value += cardValue;
        if (card.value === 'A') aces++;
      }

      // Adjust for aces
      while (value > 21 && aces > 0) {
        value -= 10;
        aces--;
      }

      return value;
    }

    function isBlackjack(cards) {
      return cards.length === 2 && calculateHandValue(cards) === 21;
    }

    function hasAce(cards) {
      return cards.some(card => card.value === 'A');
    }

    function isSoftHand(cards) {
      if (!hasAce(cards)) return false;
      let value = 0;
      let aces = 0;
      
      for (const card of cards) {
        const cardValue = getCardNumericValue(card);
        value += cardValue;
        if (card.value === 'A') aces++;
      }
      
      // It's soft if we're counting an ace as 11
      return value <= 21 && aces > 0;
    }

    function isPair(cards) {
      if (cards.length !== 2) return false;
      const val1 = getCardNumericValue(cards[0]);
      const val2 = getCardNumericValue(cards[1]);
      return val1 === val2;
    }

    function getBasicStrategyAction(playerCards, dealerUpCard, canDouble = true) {
      const playerValue = calculateHandValue(playerCards);
      const dealerValue = getCardNumericValue(dealerUpCard);
      const soft = isSoftHand(playerCards);
      const pair = isPair(playerCards);
      
      // Pair splitting logic (simplified - not implementing splits in UI, but for strategy reference)
      if (pair && playerCards.length === 2) {
        const pairValue = getCardNumericValue(playerCards[0]);
        // Always split Aces and 8s
        if (pairValue === 11 || pairValue === 8) {
          return 'split';
        }
        // Never split 10s, 5s, 4s
        if (pairValue === 10 || pairValue === 5 || pairValue === 4) {
          // Continue to regular strategy
        } else if (pairValue === 9) {
          if (dealerValue === 7 || dealerValue >= 10) return 'stand';
          return 'split';
        } else if (pairValue === 7) {
          if (dealerValue <= 7) return 'split';
          return 'hit';
        } else if (pairValue === 6) {
          if (dealerValue >= 2 && dealerValue <= 6) return 'split';
          return 'hit';
        } else if (pairValue === 3 || pairValue === 2) {
          if (dealerValue >= 4 && dealerValue <= 7) return 'split';
          return 'hit';
        }
      }
      
      // Soft hands (hands with Ace counted as 11)
      if (soft && playerValue <= 21) {
        if (playerValue >= 19) return 'stand'; // A-8 or better
        if (playerValue === 18) { // A-7
          if (dealerValue >= 9) return 'hit';
          if (dealerValue >= 3 && dealerValue <= 6 && canDouble) return 'double';
          return 'stand';
        }
        if (playerValue === 17) { // A-6
          if (dealerValue >= 3 && dealerValue <= 6 && canDouble) return 'double';
          return 'hit';
        }
        if (playerValue === 16 || playerValue === 15) { // A-5, A-4
          if (dealerValue >= 4 && dealerValue <= 6 && canDouble) return 'double';
          return 'hit';
        }
        if (playerValue === 14 || playerValue === 13) { // A-3, A-2
          if (dealerValue >= 5 && dealerValue <= 6 && canDouble) return 'double';
          return 'hit';
        }
        return 'hit';
      }
      
      // Hard hands
      if (playerValue >= 17) return 'stand';
      
      if (playerValue === 16) {
        if (dealerValue >= 7) return 'hit';
        return 'stand';
      }
      
      if (playerValue === 15) {
        if (dealerValue >= 7) return 'hit';
        return 'stand';
      }
      
      if (playerValue === 14 || playerValue === 13) {
        if (dealerValue >= 7) return 'hit';
        return 'stand';
      }
      
      if (playerValue === 12) {
        if (dealerValue >= 4 && dealerValue <= 6) return 'stand';
        return 'hit';
      }
      
      if (playerValue === 11) {
        if (canDouble) return 'double';
        return 'hit';
      }
      
      if (playerValue === 10) {
        if (dealerValue <= 9 && canDouble) return 'double';
        return 'hit';
      }
      
      if (playerValue === 9) {
        if (dealerValue >= 3 && dealerValue <= 6 && canDouble) return 'double';
        return 'hit';
      }
      
      return 'hit'; // For hands 8 or less
    }

    function checkPlayerDecision(action, playerCards, dealerUpCard, canDouble) {
      const optimalAction = getBasicStrategyAction(playerCards, dealerUpCard, canDouble);
      
      // Map split to stand for comparison since we don't implement splitting
      const normalizedOptimal = optimalAction === 'split' ? 'stand' : optimalAction;
      
      return {
        isCorrect: action === normalizedOptimal,
        optimalAction: optimalAction,
        playerAction: action
      };
    }

    function showStrategyFeedback(result, playerValue, dealerValue) {
      const feedbackEl = document.getElementById('bj-strategy-feedback');
      
      if (result.isCorrect) {
        feedbackEl.className = 'bj-strategy-feedback correct';
        feedbackEl.innerHTML = `<strong>‚úì Correct!</strong> ${result.playerAction.toUpperCase()} was the optimal play (${playerValue} vs ${dealerValue}).`;
        bjCorrectPlays++;
      } else {
        feedbackEl.className = 'bj-strategy-feedback incorrect';
        const suggestion = result.optimalAction === 'split' 
          ? 'SPLIT (not available in this version, so STAND)' 
          : result.optimalAction.toUpperCase();
        feedbackEl.innerHTML = `<strong>‚úó Suboptimal.</strong> You chose <strong>${result.playerAction.toUpperCase()}</strong>, but basic strategy suggests <strong>${suggestion}</strong> (${playerValue} vs ${dealerValue}).`;
        bjIncorrectPlays++;
      }
      
      feedbackEl.style.display = 'block';
      
      // Update stats
      document.getElementById('bj-correct-plays').textContent = bjCorrectPlays;
      document.getElementById('bj-incorrect-plays').textContent = bjIncorrectPlays;
      
      const total = bjCorrectPlays + bjIncorrectPlays;
      if (total > 0) {
        const accuracy = ((bjCorrectPlays / total) * 100).toFixed(1);
        const accuracyEl = document.getElementById('bj-accuracy');
        accuracyEl.textContent = accuracy + '%';
        accuracyEl.className = 'stat-value ' + (parseFloat(accuracy) >= 80 ? 'good' : 'bad');
      }
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        feedbackEl.style.display = 'none';
      }, 5000);
    }

    function dealCard() {
      if (bjDeck.length === 0) {
        showError('Deck is empty! Shuffling new shoe...');
        bjDeck = createDeck(bjNumDecks);
      }
      return bjDeck.pop();
    }

    function renderCard(card, hidden = false) {
      const isRed = card.suit === '‚ô•' || card.suit === '‚ô¶';
      if (hidden) {
        return '<div class="bj-card hidden">üÇ†</div>';
      }
      return `
        <div class="bj-card ${isRed ? 'red' : 'black'}">
          <div class="card-value">${card.value}</div>
          <div class="card-suit">${card.suit}</div>
        </div>
      `;
    }

    function renderHand(cards, hideFirst = false) {
      return cards.map((card, index) => {
        if (hideFirst && index === 0) {
          return renderCard(card, true);
        }
        return renderCard(card, false);
      }).join('');
    }

    function updateDeckInfo() {
      const cardsRemaining = bjDeck.length;
      const totalCards = bjNumDecks * 52;
      const penetration = ((totalCards - cardsRemaining) / totalCards * 100).toFixed(1);
      
      document.getElementById('bj-cards-remaining').textContent = cardsRemaining;
      document.getElementById('bj-penetration').textContent = penetration + '%';
      document.getElementById('bj-deck-count').textContent = `${totalCards} cards total`;
    }

    function updatePlayerDisplay() {
      // Update dealer
      const dealerEl = document.getElementById('bj-dealer');
      const dealerCardsEl = document.getElementById('dealer-cards');
      const dealerValueEl = document.getElementById('dealer-value');
      const dealerStatusEl = document.getElementById('dealer-status');

      const hideFirstCard = bjGameInProgress && bjCurrentPlayerIndex !== -2;
      dealerCardsEl.innerHTML = renderHand(bjDealer.cards, hideFirstCard);
      
      if (hideFirstCard && bjDealer.cards.length > 0) {
        const visibleValue = calculateHandValue(bjDealer.cards.slice(1));
        dealerValueEl.innerHTML = `Showing: <strong>${visibleValue}</strong>`;
      } else if (bjDealer.cards.length > 0) {
        const value = calculateHandValue(bjDealer.cards);
        dealerValueEl.innerHTML = `Hand Value: <strong>${value}</strong>`;
      } else {
        dealerValueEl.innerHTML = '';
      }

      // Update players
      const playersAreaEl = document.getElementById('bj-players-area');
      playersAreaEl.innerHTML = bjPlayers.map((player, index) => {
        const value = calculateHandValue(player.cards);
        const isActive = index === bjCurrentPlayerIndex;
        const isHuman = player.isHuman;
        
        let statusHTML = '';
        if (player.status) {
          const statusClass = player.status === 'Win' ? 'win' : 
                             player.status === 'Lose' ? 'lose' : 
                             player.status === 'Push' ? 'push' :
                             player.status === 'Blackjack!' ? 'blackjack' : '';
          statusHTML = `<div class="bj-player-status ${statusClass}">${player.status}</div>`;
        }

        return `
          <div class="bj-player ${isActive ? 'active' : ''}" id="player-${index}">
            <div class="bj-player-header">
              <div class="bj-player-name">
                ${isHuman ? 'üë§ You' : `ü§ñ ${player.name}`}
                ${isActive ? '<span style="color: #22c55e; margin-left: 4px;">‚óè</span>' : ''}
              </div>
              ${statusHTML}
            </div>
            <div class="bj-cards">${renderHand(player.cards)}</div>
            <div class="bj-hand-value">
              Hand Value: <strong>${value}${value > 21 ? ' (BUST)' : ''}</strong>
            </div>
            <div class="bj-bet-info">Bet: <strong>$${player.bet}</strong></div>
          </div>
        `;
      }).join('');
    }

    function aiPlayerDecision(player) {
      const handValue = calculateHandValue(player.cards);
      const dealerUpCard = bjDealer.cards[1];
      const dealerValue = getCardNumericValue(dealerUpCard);

      // Basic strategy simulation
      // Simplified AI logic
      if (handValue < 12) return 'hit';
      if (handValue >= 17) return 'stand';
      
      // Between 12-16, decide based on dealer up card
      if (handValue <= 16) {
        if (dealerValue >= 7) return 'hit';
        return 'stand';
      }
      
      return 'stand';
    }

    async function playAITurn(playerIndex) {
      const player = bjPlayers[playerIndex];
      
      while (true) {
        await new Promise(resolve => setTimeout(resolve, 800));
        
        const decision = aiPlayerDecision(player);
        
        if (decision === 'hit') {
          player.cards.push(dealCard());
          updatePlayerDisplay();
          updateDeckInfo();
          
          const value = calculateHandValue(player.cards);
          if (value > 21) {
            player.busted = true;
            break;
          }
        } else {
          break;
        }
      }
    }

    async function dealerTurn() {
      bjCurrentPlayerIndex = -2; // Dealer's turn
      updatePlayerDisplay();
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      while (calculateHandValue(bjDealer.cards) < 17) {
        await new Promise(resolve => setTimeout(resolve, 800));
        bjDealer.cards.push(dealCard());
        updatePlayerDisplay();
        updateDeckInfo();
      }
      
      const dealerValue = calculateHandValue(bjDealer.cards);
      if (dealerValue > 21) {
        bjDealer.busted = true;
        document.getElementById('dealer-status').textContent = 'BUST';
        document.getElementById('dealer-status').className = 'bj-player-status lose';
      }
    }

    function resolveHands() {
      const dealerValue = calculateHandValue(bjDealer.cards);
      const dealerBlackjack = isBlackjack(bjDealer.cards);
      
      bjPlayers.forEach(player => {
        const playerValue = calculateHandValue(player.cards);
        const playerBlackjack = isBlackjack(player.cards);
        
        if (player.busted) {
          player.status = 'Lose';
          if (player.isHuman) {
            balance -= player.bet;
          }
        } else if (playerBlackjack && !dealerBlackjack) {
          player.status = 'Blackjack!';
          if (player.isHuman) {
            balance += player.bet * 1.5; // 3:2 payout
          }
        } else if (bjDealer.busted) {
          player.status = 'Win';
          if (player.isHuman) {
            balance += player.bet;
          }
        } else if (playerValue > dealerValue) {
          player.status = 'Win';
          if (player.isHuman) {
            balance += player.bet;
          }
        } else if (playerValue < dealerValue) {
          player.status = 'Lose';
          if (player.isHuman) {
            balance -= player.bet;
          }
        } else {
          player.status = 'Push';
          // No change to balance on push
        }
      });
      
      updateBalanceDisplay();
      updatePlayerDisplay();
    }

    async function startBlackjackGame() {
      const numAIPlayers = parseInt(document.getElementById('bj-num-players').value);
      bjPlayerBet = parseInt(document.getElementById('bj-bet-amount').value);
      
      if (bjPlayerBet <= 0 || bjPlayerBet > balance) {
        showError('Invalid bet amount!');
        return;
      }
      
      // Initialize players
      bjPlayers = [
        { name: 'You', cards: [], bet: bjPlayerBet, isHuman: true, busted: false, status: '' }
      ];
      
      for (let i = 0; i < numAIPlayers; i++) {
        const aiNames = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank'];
        bjPlayers.push({
          name: aiNames[i],
          cards: [],
          bet: Math.floor(Math.random() * 50) + 10,
          isHuman: false,
          busted: false,
          status: ''
        });
      }
      
      // Initialize dealer
      bjDealer = { cards: [], busted: false };
      document.getElementById('dealer-status').textContent = '';
      
      bjGameInProgress = true;
      bjCurrentPlayerIndex = -1;
      
      // Deal initial cards
      for (let i = 0; i < 2; i++) {
        for (const player of bjPlayers) {
          player.cards.push(dealCard());
        }
        bjDealer.cards.push(dealCard());
      }
      
      updatePlayerDisplay();
      updateDeckInfo();
      
      // Check for dealer blackjack
      if (isBlackjack(bjDealer.cards)) {
        await dealerTurn();
        resolveHands();
        bjGameInProgress = false;
        document.getElementById('bj-game-actions').style.display = 'none';
        return;
      }
      
      // Check for player blackjacks
      const humanPlayer = bjPlayers[0];
      if (isBlackjack(humanPlayer.cards)) {
        // Human has blackjack, skip to AI players
        bjCurrentPlayerIndex = 1;
      } else {
        // Start with human player
        bjCurrentPlayerIndex = 0;
      }
      
      if (bjCurrentPlayerIndex === 0) {
        // Show action buttons for human
        document.getElementById('bj-game-actions').style.display = 'flex';
        document.getElementById('bj-double-btn').disabled = false;
      } else {
        document.getElementById('bj-game-actions').style.display = 'none';
        // Continue to AI players or dealer
        continueGame();
      }
      
      updatePlayerDisplay();
    }

    async function continueGame() {
      // Play AI turns
      while (bjCurrentPlayerIndex < bjPlayers.length) {
        if (bjCurrentPlayerIndex < 0) {
          bjCurrentPlayerIndex++;
          continue;
        }
        
        const currentPlayer = bjPlayers[bjCurrentPlayerIndex];
        
        if (!currentPlayer.isHuman && !currentPlayer.busted && !isBlackjack(currentPlayer.cards)) {
          updatePlayerDisplay();
          await playAITurn(bjCurrentPlayerIndex);
        }
        
        bjCurrentPlayerIndex++;
      }
      
      // Dealer's turn
      const anyPlayerNotBusted = bjPlayers.some(p => !p.busted);
      if (anyPlayerNotBusted) {
        await dealerTurn();
      }
      
      // Resolve all hands
      resolveHands();
      bjGameInProgress = false;
      bjCurrentPlayerIndex = -1;
      document.getElementById('bj-game-actions').style.display = 'none';
    }

    function playerHit() {
      const player = bjPlayers[bjCurrentPlayerIndex];
      const dealerUpCard = bjDealer.cards[1];
      
      // Check strategy before executing
      const canDouble = player.cards.length === 2 && balance >= player.bet;
      const result = checkPlayerDecision('hit', player.cards, dealerUpCard, canDouble);
      const playerValue = calculateHandValue(player.cards);
      const dealerValue = getCardNumericValue(dealerUpCard);
      
      player.cards.push(dealCard());
      updatePlayerDisplay();
      updateDeckInfo();
      
      // Show feedback
      showStrategyFeedback(result, playerValue, dealerValue);
      
      const value = calculateHandValue(player.cards);
      if (value > 21) {
        player.busted = true;
        document.getElementById('bj-game-actions').style.display = 'none';
        bjCurrentPlayerIndex++;
        continueGame();
      } else {
        // Disable double down after first hit
        document.getElementById('bj-double-btn').disabled = true;
      }
    }

    function playerStand() {
      const player = bjPlayers[bjCurrentPlayerIndex];
      const dealerUpCard = bjDealer.cards[1];
      
      // Check strategy
      const canDouble = player.cards.length === 2 && balance >= player.bet;
      const result = checkPlayerDecision('stand', player.cards, dealerUpCard, canDouble);
      const playerValue = calculateHandValue(player.cards);
      const dealerValue = getCardNumericValue(dealerUpCard);
      
      showStrategyFeedback(result, playerValue, dealerValue);
      
      document.getElementById('bj-game-actions').style.display = 'none';
      bjCurrentPlayerIndex++;
      continueGame();
    }

    function playerDouble() {
      const player = bjPlayers[bjCurrentPlayerIndex];
      
      if (balance < player.bet) {
        showError('Insufficient balance to double down!');
        return;
      }
      
      const dealerUpCard = bjDealer.cards[1];
      
      // Check strategy
      const result = checkPlayerDecision('double', player.cards, dealerUpCard, true);
      const playerValue = calculateHandValue(player.cards);
      const dealerValue = getCardNumericValue(dealerUpCard);
      
      showStrategyFeedback(result, playerValue, dealerValue);
      
      player.bet *= 2;
      player.cards.push(dealCard());
      updatePlayerDisplay();
      updateDeckInfo();
      
      const value = calculateHandValue(player.cards);
      if (value > 21) {
        player.busted = true;
      }
      
      document.getElementById('bj-game-actions').style.display = 'none';
      bjCurrentPlayerIndex++;
      continueGame();
    }

    // --- Strategy descriptions ---
    const STRATEGIES = {
      flat: 'Bet the same amount every round. Simple and predictable. Works with any odds.',
      martingale: 'Double your bet after each loss. High risk, aims to recover losses with one win. Works with 1:1 and 2:1 odds.',
      'dual-martingale': '2 independent Martingale progressions on 2:1 bets. Each bet doubles independently after loss. Covers ~63% of numbers with higher capital requirements.',
      'reverse-martingale': 'Double your bet after each win. Ride winning streaks. Works with any odds.',
      dalembert: 'Increase bet by 1 unit after loss, decrease by 1 after win. Gentler progression.',
      fibonacci: 'Follow Fibonacci sequence (1,1,2,3,5,8...) after losses. Mathematical progression.',
      labouchere: 'Create a sequence (1,2,3,4), bet sum of ends, cross off on win. Complex strategy.',
      paroli: 'Let winnings ride for 3 wins (1-3-2-6 system), then reset. Conservative progression.'
    };

    // --- Simulation state ---
    let simulationRunning = false;
    let simulationStopped = false;

    // --- Core game state ---
    const START_BALANCE = 1000;
    let balance = START_BALANCE;
    let lastBalance = START_BALANCE;

    let totalSpins = 0;
    let redCount = 0;
    let blackCount = 0;
    let greenCount = 0;

    const redNumbers = new Set([
      1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36
    ]);

    // Betting system
    let currentChipValue = 1;
    let placedBets = []; // Array of {type, value, amount}
    let lastBet = null; // Store the last bet for history tracking

    // --- DOM elements ---
    const balanceValueEl = document.getElementById("balance-value");
    const balanceChangeEl = document.getElementById("balance-change");
    const spinBtn = document.getElementById("spin-btn");
    const resetBtn = document.getElementById("reset-btn");
    const clearBetsBtn = document.getElementById("clear-bets-btn");
    const repeatBetBtn = document.getElementById("repeat-bet-btn");
    const errorEl = document.getElementById("error");
    const latestResultEl = document.getElementById("latest-result");
    const historyListEl = document.getElementById("history-list");
    const wheelCenterEl = document.getElementById("wheel-center");
    const wheelInnerEl = document.getElementById("wheel-inner");
    const rouletteTableEl = document.getElementById("roulette-table");
    const betChipsListEl = document.getElementById("bet-chips-list");
    const totalBetAmountEl = document.getElementById("total-bet-amount");
    const spinTotalEl = document.getElementById("spin-total");

    const statSpinsEl = document.getElementById("stat-spins");
    const statRedEl = document.getElementById("stat-red");
    const statBlackEl = document.getElementById("stat-black");
    const statGreenEl = document.getElementById("stat-green");
    const statProfitEl = document.getElementById("stat-profit");

    // --- Utility: secure RNG spin ---
    function spinWheel() {
      const wheelSize = 38; // 0, 00, 1‚Äì36
      const arr = new Uint32Array(1);
      crypto.getRandomValues(arr);
      const result = arr[0] % wheelSize;
      // Map 37 to "00"
      return result === 37 ? "00" : result;
    }

    function getColor(num) {
      if (num === 0 || num === "00") return "green";
      return redNumbers.has(num) ? "red" : "black";
    }

    function formatColorLabel(color, num) {
      if (color === "red") return "Red";
      if (color === "black") return "Black";
      return num === "00" ? "Green (00)" : "Green (0)";
    }

    // Generate roulette table layout
    function generateRouletteTable() {
      const numbers = [
        [3,6,9,12,15,18,21,24,27,30,33,36],
        [2,5,8,11,14,17,20,23,26,29,32,35],
        [1,4,7,10,13,16,19,22,25,28,31,34]
      ];

      // Zero section
      const zeroSection = document.createElement('div');
      zeroSection.className = 'table-side';
      zeroSection.innerHTML = `
        <div class="bet-cell number-cell green" data-bet-type="straight" data-value="0">0</div>
        <div class="bet-cell number-cell green" data-bet-type="straight" data-value="00">00</div>
      `;

      // Main number grid
      const mainGrid = document.createElement('div');
      mainGrid.className = 'table-main';
      
      numbers.forEach(row => {
        row.forEach(num => {
          const cell = document.createElement('div');
          const isRed = redNumbers.has(num);
          cell.className = `bet-cell number-cell ${isRed ? 'red' : ''}`;
          cell.textContent = num;
          cell.setAttribute('data-bet-type', 'straight');
          cell.setAttribute('data-value', num);
          mainGrid.appendChild(cell);
        });
      });

      // 2:1 column bets
      const columnSection = document.createElement('div');
      columnSection.className = 'table-side';
      columnSection.innerHTML = `
        <div class="column-bet" data-bet-type="column" data-value="3">2:1</div>
        <div class="column-bet" data-bet-type="column" data-value="2">2:1</div>
        <div class="column-bet" data-bet-type="column" data-value="1">2:1</div>
      `;

      rouletteTableEl.appendChild(zeroSection);
      rouletteTableEl.appendChild(mainGrid);
      rouletteTableEl.appendChild(columnSection);

      // Outside bets
      const outsideBets = document.createElement('div');
      outsideBets.className = 'outside-bets-row';
      outsideBets.innerHTML = `
        <div class="outside-bet" data-bet-type="dozen" data-value="1">1st 12</div>
        <div class="outside-bet" data-bet-type="dozen" data-value="2">2nd 12</div>
        <div class="outside-bet" data-bet-type="dozen" data-value="3">3rd 12</div>
        <div class="outside-bet" data-bet-type="red" data-value="red">Red</div>
        <div class="outside-bet" data-bet-type="black" data-value="black">Black</div>
        <div class="outside-bet" data-bet-type="odd" data-value="odd">Odd</div>
        <div class="outside-bet" data-bet-type="even" data-value="even">Even</div>
        <div class="outside-bet" data-bet-type="low" data-value="low">1-18</div>
        <div class="outside-bet" data-bet-type="high" data-value="high">19-36</div>
      `;
      outsideBets.style.gridColumn = '2 / 3';
      outsideBets.style.marginTop = '10px';
      rouletteTableEl.appendChild(outsideBets);

      // Add click handlers
      document.querySelectorAll('[data-bet-type]').forEach(el => {
        el.addEventListener('click', () => placeBet(el));
      });
    }

    function placeBet(element) {
      const betType = element.getAttribute('data-bet-type');
      const value = element.getAttribute('data-value');
      
      if (balance < currentChipValue) {
        showError('Insufficient balance for this chip value!');
        return;
      }

      const totalBets = getTotalBetAmount();
      if (totalBets + currentChipValue > balance) {
        showError('Total bets would exceed your balance!');
        return;
      }

      placedBets.push({
        type: betType,
        value: value,
        amount: currentChipValue
      });

      element.classList.add('active');
      updateBetDisplay();
      errorEl.textContent = '';
    }

    function getTotalBetAmount() {
      return placedBets.reduce((sum, bet) => sum + bet.amount, 0);
    }

    function updateBetDisplay() {
      const total = getTotalBetAmount();
      totalBetAmountEl.textContent = total;
      spinTotalEl.textContent = total;

      // Group bets by type and value
      const grouped = {};
      placedBets.forEach(bet => {
        const key = `${bet.type}-${bet.value}`;
        if (!grouped[key]) {
          grouped[key] = { ...bet, count: 0, totalAmount: 0 };
        }
        grouped[key].count++;
        grouped[key].totalAmount += bet.amount;
      });

      betChipsListEl.innerHTML = Object.values(grouped).map((bet, idx) => `
        <div class="bet-chip">
          ${getBetLabel(bet.type, bet.value)}: $${bet.totalAmount}
          <span class="bet-chip-remove" onclick="removeBetGroup('${bet.type}', '${bet.value}')">‚úï</span>
        </div>
      `).join('');

      // Update chip indicators on table
      document.querySelectorAll('.chip-indicator').forEach(el => el.remove());
      Object.values(grouped).forEach(bet => {
        const selector = `[data-bet-type="${bet.type}"][data-value="${bet.value}"]`;
        const element = document.querySelector(selector);
        if (element && !element.querySelector('.chip-indicator')) {
          const indicator = document.createElement('div');
          indicator.className = 'chip-indicator';
          indicator.textContent = bet.totalAmount;
          element.appendChild(indicator);
        }
      });

      spinBtn.disabled = total === 0;
      repeatBetBtn.disabled = !lastBet || lastBet.length === 0;
    }

    function getBetLabel(type, value) {
      switch(type) {
        case 'straight': return value;
        case 'red': return 'Red';
        case 'black': return 'Black';
        case 'odd': return 'Odd';
        case 'even': return 'Even';
        case 'low': return '1-18';
        case 'high': return '19-36';
        case 'dozen': return `Dozen ${value}`;
        case 'column': return `Col ${value}`;
        default: return type;
      }
    }

    window.removeBetGroup = function(type, value) {
      placedBets = placedBets.filter(bet => !(bet.type === type && bet.value === value));
      updateBetDisplay();
      
      const element = document.querySelector(`[data-bet-type="${type}"][data-value="${value}"]`);
      if (element) element.classList.remove('active');
    };

    function clearAllBets() {
      placedBets = [];
      document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
      document.querySelectorAll('.chip-indicator').forEach(el => el.remove());
      updateBetDisplay();
    }

    function repeatLastBet() {
      if (!lastBet || lastBet.length === 0) {
        showError('No previous bet to repeat!');
        return;
      }

      const totalLastBet = lastBet.reduce((sum, bet) => sum + bet.amount, 0);
      if (balance < totalLastBet) {
        showError('Insufficient balance to repeat last bet!');
        return;
      }

      const currentTotal = getTotalBetAmount();
      if (currentTotal + totalLastBet > balance) {
        showError('Repeating last bet would exceed your balance!');
        return;
      }

      // Add all bets from lastBet
      lastBet.forEach(bet => {
        placedBets.push({ ...bet });
      });

      // Update visual indicators
      lastBet.forEach(bet => {
        const element = document.querySelector(`[data-bet-type="${bet.type}"][data-value="${bet.value}"]`);
        if (element) {
          element.classList.add('active');
        }
      });

      updateBetDisplay();
      errorEl.textContent = '';
    }

    function calculateWinnings(outcomeNumber) {
      let totalWin = 0;
      const outcomeStr = String(outcomeNumber);
      const outcomeNum = typeof outcomeNumber === 'number' ? outcomeNumber : (outcomeNumber === '00' ? -1 : 0);
      const color = getColor(outcomeNumber);

      placedBets.forEach(bet => {
        let multiplier = 0;

        switch(bet.type) {
          case 'straight':
            multiplier = outcomeStr === bet.value ? 36 : 0;
            break;
          case 'red':
            multiplier = color === 'red' ? 2 : 0;
            break;
          case 'black':
            multiplier = color === 'black' ? 2 : 0;
            break;
          case 'odd':
            multiplier = (outcomeNum > 0 && outcomeNum % 2 === 1) ? 2 : 0;
            break;
          case 'even':
            multiplier = (outcomeNum > 0 && outcomeNum % 2 === 0) ? 2 : 0;
            break;
          case 'low':
            multiplier = (outcomeNum >= 1 && outcomeNum <= 18) ? 2 : 0;
            break;
          case 'high':
            multiplier = (outcomeNum >= 19 && outcomeNum <= 36) ? 2 : 0;
            break;
          case 'dozen':
            const dozenNum = parseInt(bet.value);
            const start = (dozenNum - 1) * 12 + 1;
            const end = dozenNum * 12;
            multiplier = (outcomeNum >= start && outcomeNum <= end) ? 3 : 0;
            break;
          case 'column':
            const colNum = parseInt(bet.value);
            multiplier = (outcomeNum > 0 && (outcomeNum - colNum) % 3 === 0) ? 3 : 0;
            break;
        }

        totalWin += bet.amount * multiplier;
      });

      return totalWin;
    }

    function showError(message) {
      errorEl.textContent = message;
      setTimeout(() => errorEl.textContent = '', 3000);
    }

    function updateStats(outcomeNumber) {
      totalSpins++;
      const color = getColor(outcomeNumber);
      if (color === "red") redCount++;
      else if (color === "black") blackCount++;
      else greenCount++;

      statSpinsEl.textContent = totalSpins;
      statRedEl.textContent = redCount;
      statBlackEl.textContent = blackCount;
      statGreenEl.textContent = greenCount;
      const netProfit = balance - START_BALANCE;
      const sign = netProfit >= 0 ? "+" : "";
      statProfitEl.textContent = `${sign}$${netProfit}`;
      statProfitEl.style.color = netProfit >= 0 ? "#4ade80" : "#f97373";
    }

    function updateBalanceDisplay() {
      balanceValueEl.textContent = balance;
      const diff = balance - lastBalance;
      balanceChangeEl.textContent = "";
      balanceChangeEl.className = "balance-change";

      if (diff !== 0) {
        const sign = diff > 0 ? "+" : "";
        balanceChangeEl.textContent = `${sign}$${diff}`;
        balanceChangeEl.classList.add(diff > 0 ? "positive" : "negative");
      }
      lastBalance = balance;
    }

    function updateLatestResult(outcomeNumber, netProfit, totalBet, betCount) {
      const color = getColor(outcomeNumber);
      const win = netProfit > 0;
      const numberText = outcomeNumber == null ? "‚Äì" : outcomeNumber;

      // Generate last bet summary
      let lastBetSummary = '';
      if (lastBet && lastBet.length > 0) {
        const grouped = {};
        lastBet.forEach(bet => {
          const key = `${bet.type}-${bet.value}`;
          if (!grouped[key]) {
            grouped[key] = { ...bet, totalAmount: 0 };
          }
          grouped[key].totalAmount += bet.amount;
        });
        
        const betsList = Object.values(grouped)
          .map(bet => `${getBetLabel(bet.type, bet.value)} ($${bet.totalAmount})`)
          .join(', ');
        lastBetSummary = `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(148,163,184,0.2);">
          <strong style="color: var(--muted); font-size: 11px;">Your bets:</strong> ${betsList}
        </div>`;
      }

      latestResultEl.innerHTML = `
        <div class="result-number">
          ${numberText}
          <span class="chip ${win ? "chip-win" : "chip-loss"}">
            ${win ? "Win" : "Loss"} ¬∑ ${betCount} bet${betCount > 1 ? 's' : ''}
          </span>
        </div>
        <div class="result-details">
          Outcome: <strong>${formatColorLabel(color, outcomeNumber)}</strong>.
          Total wagered: <strong>$${totalBet}</strong>.<br/>
          ${win
            ? `Net profit: <strong style="color: #4ade80">+$${netProfit}</strong> (total return: $${netProfit + totalBet})`
            : `You lost <strong style="color: #f97373">-$${totalBet}</strong>.`}
          ${lastBetSummary}
        </div>
      `;

      wheelCenterEl.textContent = outcomeNumber;
    }

    function addHistoryItem(outcomeNumber, netProfit, totalBet) {
      const color = getColor(outcomeNumber);
      const colorClass =
        color === "red" ? "number-red" : color === "black" ? "number-black" : "number-green";

      const histItem = document.createElement("div");
      histItem.className = "history-item";
      histItem.innerHTML = `
        <div class="number-pill ${colorClass}">
          ${outcomeNumber}
        </div>
        <div class="hist-meta">
          Total bet<br/>
          Stake: $${totalBet}
        </div>
        <div class="${netProfit > 0 ? "hist-win" : "hist-loss"}">
          ${netProfit > 0 ? "+$" + netProfit : "-$" + totalBet}
        </div>
      `;

      historyListEl.prepend(histItem);
      // Limit to last 20
      while (historyListEl.children.length > 20) {
        historyListEl.removeChild(historyListEl.lastChild);
      }
    }

    function animateWheelSpin(onComplete) {
      // Enhanced spin animation with blur effect for realism
      const fullRotations = 5 + Math.random() * 4;
      const currentRotation = parseFloat(
        wheelInnerEl.getAttribute("data-rotation") || "0"
      );
      const targetRotation = currentRotation + fullRotations * 360;
      
      // Add blur during spin
      wheelInnerEl.style.filter = "blur(2px)";
      wheelCenterEl.textContent = "...";
      wheelCenterEl.style.opacity = "0.5";
      
      wheelInnerEl.style.transition = "transform 2s cubic-bezier(0.17, 0.67, 0.12, 0.99)";
      wheelInnerEl.style.transform = `rotate(${targetRotation}deg)`;
      wheelInnerEl.setAttribute("data-rotation", targetRotation.toString());

      setTimeout(() => {
        // Remove blur and reset
        wheelInnerEl.style.transition = "";
        wheelInnerEl.style.filter = "";
        wheelCenterEl.style.opacity = "1";
        if (typeof onComplete === "function") onComplete();
      }, 2000);
    }

    // --- Strategy Simulator Functions ---
    function getNextBet(strategy, currentBet, lastWin, sequence, winStreak, lossStreak, initialBet, maxBet) {
      let nextBet = currentBet;

      switch(strategy) {
        case 'flat':
          nextBet = initialBet;
          break;

        case 'martingale':
          if (lastWin) {
            nextBet = initialBet;
          } else {
            nextBet = Math.min(currentBet * 2, maxBet);
          }
          break;

        case 'reverse-martingale':
          if (lastWin) {
            nextBet = Math.min(currentBet * 2, maxBet);
          } else {
            nextBet = initialBet;
          }
          break;

        case 'dalembert':
          if (lastWin) {
            nextBet = Math.max(currentBet - initialBet, initialBet);
          } else {
            nextBet = Math.min(currentBet + initialBet, maxBet);
          }
          break;

        case 'fibonacci':
          if (!sequence || sequence.length === 0) {
            sequence = [initialBet, initialBet];
          }
          if (lastWin) {
            // Move back 2 positions
            sequence = sequence.slice(0, -2);
            if (sequence.length === 0) sequence = [initialBet];
            nextBet = sequence[sequence.length - 1];
          } else {
            // Add next number in sequence
            const next = sequence[sequence.length - 1] + sequence[sequence.length - 2];
            sequence.push(Math.min(next, maxBet));
            nextBet = sequence[sequence.length - 1];
          }
          break;

        case 'labouchere':
          if (!sequence || sequence.length === 0) {
            sequence = [initialBet, initialBet * 2, initialBet * 3, initialBet * 4];
          }
          if (lastWin) {
            // Remove first and last
            sequence = sequence.slice(1, -1);
            if (sequence.length === 0) {
              sequence = [initialBet];
              nextBet = initialBet;
            } else {
              nextBet = Math.min(sequence[0] + sequence[sequence.length - 1], maxBet);
            }
          } else {
            // Add sum to end
            const sum = sequence[0] + sequence[sequence.length - 1];
            sequence.push(sum);
            nextBet = Math.min(sequence[0] + sequence[sequence.length - 1], maxBet);
          }
          break;

        case 'paroli':
          if (lastWin) {
            if (winStreak < 3) {
              nextBet = Math.min(currentBet * 2, maxBet);
            } else {
              nextBet = initialBet; // Reset after 3 wins
            }
          } else {
            nextBet = initialBet;
          }
          break;
      }

      return { nextBet, sequence };
    }

    function checkBetWin(betTarget, outcomeNumber) {
      const outcomeStr = String(outcomeNumber);
      const outcomeNum = typeof outcomeNumber === 'number' ? outcomeNumber : (outcomeNumber === '00' ? -1 : 0);
      const color = getColor(outcomeNumber);

      switch(betTarget) {
        case 'red':
          return color === 'red';
        case 'black':
          return color === 'black';
        case 'odd':
          return outcomeNum > 0 && outcomeNum % 2 === 1;
        case 'even':
          return outcomeNum > 0 && outcomeNum % 2 === 0;
        case 'low':
          return outcomeNum >= 1 && outcomeNum <= 18;
        case 'high':
          return outcomeNum >= 19 && outcomeNum <= 36;
        case 'dozen-1':
          return outcomeNum >= 1 && outcomeNum <= 12;
        case 'dozen-2':
          return outcomeNum >= 13 && outcomeNum <= 24;
        case 'dozen-3':
          return outcomeNum >= 25 && outcomeNum <= 36;
        case 'column-1':
          return outcomeNum > 0 && (outcomeNum - 1) % 3 === 0;
        case 'column-2':
          return outcomeNum > 0 && (outcomeNum - 2) % 3 === 0;
        case 'column-3':
          return outcomeNum > 0 && (outcomeNum - 3) % 3 === 0;
        default:
          return false;
      }
    }

    function getBetPayout(betTarget) {
      // Returns the payout multiplier (including original bet)
      // 1:1 bets return 2x (bet + winnings)
      // 2:1 bets return 3x (bet + 2x winnings)
      if (betTarget.startsWith('dozen-') || betTarget.startsWith('column-')) {
        return 3; // 2:1 payout = 3x total return
      }
      return 2; // 1:1 payout = 2x total return
    }

    function getBetOddsLabel(betTarget) {
      if (betTarget.startsWith('dual-')) {
        return '2x 2:1 bets (~63.2% chance, independent progressions)';
      }
      if (betTarget.startsWith('dozen-') || betTarget.startsWith('column-')) {
        return '2:1 (~32.4% chance)';
      }
      return '1:1 (~47.4% chance)';
    }

    function parseDualBets(dualBetTarget) {
      // Returns array of two bet targets
      const mapping = {
        'dual-dozen-1-2': ['dozen-1', 'dozen-2'],
        'dual-dozen-1-3': ['dozen-1', 'dozen-3'],
        'dual-dozen-2-3': ['dozen-2', 'dozen-3'],
        'dual-column-1-2': ['column-1', 'column-2'],
        'dual-column-1-3': ['column-1', 'column-3'],
        'dual-column-2-3': ['column-2', 'column-3']
      };
      return mapping[dualBetTarget] || null;
    }

    async function runSimulation() {
      const strategy = document.getElementById('strategy-type').value;
      const betTarget = document.getElementById('sim-bet-target').value;
      const initialBet = parseInt(document.getElementById('sim-initial-bet').value);
      const numRounds = parseInt(document.getElementById('sim-rounds').value);
      const startingBalance = parseInt(document.getElementById('sim-starting-balance').value);
      const maxBet = parseInt(document.getElementById('sim-max-bet').value);

      if (initialBet <= 0 || numRounds <= 0 || startingBalance <= 0 || maxBet <= 0) {
        showError('Please enter valid positive numbers for all fields!');
        return;
      }

      // For dual betting, need 2x the initial bet
      const minRequired = strategy === 'dual-martingale' ? initialBet * 2 : initialBet;
      if (minRequired > startingBalance) {
        showError(`Initial bet${strategy === 'dual-martingale' ? 's' : ''} cannot exceed starting bankroll!`);
        return;
      }

      simulationRunning = true;
      simulationStopped = false;
      document.getElementById('run-sim-btn').disabled = true;
      document.getElementById('stop-sim-btn').disabled = false;
      document.getElementById('sim-progress').style.display = 'block';

      let simBalance = startingBalance;
      let currentBet = initialBet;
      let wins = 0;
      let losses = 0;
      let totalWagered = 0;
      let maxBalance = startingBalance;
      let minBalance = startingBalance;
      let balanceHistory = [startingBalance];
      let sequence = null;
      let winStreak = 0;
      let lossStreak = 0;

      // Dual Martingale specific variables
      let currentBet1 = initialBet;
      let currentBet2 = initialBet;
      let dualBets = null;

      if (strategy === 'dual-martingale') {
        dualBets = parseDualBets(betTarget);
        if (!dualBets) {
          showError('Please select a dual bet target for Dual Martingale!');
          simulationRunning = false;
          document.getElementById('run-sim-btn').disabled = false;
          document.getElementById('stop-sim-btn').disabled = true;
          return;
        }
      }

      for (let round = 0; round < numRounds; round++) {
        if (simulationStopped) break;

        if (strategy === 'dual-martingale') {
          // Dual Martingale: Two independent bets
          const totalBet = currentBet1 + currentBet2;
          
          if (simBalance < totalBet) {
            break; // Can't afford both bets
          }

          // Place both bets
          simBalance -= totalBet;
          totalWagered += totalBet;

          // Spin once
          const outcome = spinWheel();
          const won1 = checkBetWin(dualBets[0], outcome);
          const won2 = checkBetWin(dualBets[1], outcome);

          // Calculate winnings for each bet independently
          const payout = getBetPayout(dualBets[0]); // Both are 2:1 bets
          let roundProfit = 0;

          if (won1) {
            roundProfit += currentBet1 * payout;
          }
          if (won2) {
            roundProfit += currentBet2 * payout;
          }

          simBalance += roundProfit;

          // Track overall win/loss for stats
          if (won1 || won2) {
            wins++;
          } else {
            losses++;
          }

          // Update each bet independently (Martingale logic)
          if (won1) {
            currentBet1 = initialBet; // Reset to base
          } else {
            currentBet1 = Math.min(currentBet1 * 2, maxBet); // Double
          }

          if (won2) {
            currentBet2 = initialBet; // Reset to base
          } else {
            currentBet2 = Math.min(currentBet2 * 2, maxBet); // Double
          }
        } else {
          // Standard single bet logic
          if (simBalance < currentBet) {
            break;
          }

          simBalance -= currentBet;
          totalWagered += currentBet;

          const outcome = spinWheel();
          const won = checkBetWin(betTarget, outcome);

          const payoutMultiplier = getBetPayout(betTarget);
          if (won) {
            simBalance += currentBet * payoutMultiplier;
            wins++;
            winStreak++;
            lossStreak = 0;
          } else {
            losses++;
            lossStreak++;
            winStreak = 0;
          }

          // Get next bet
          const result = getNextBet(strategy, currentBet, won, sequence, winStreak, lossStreak, initialBet, maxBet);
          currentBet = result.nextBet;
          sequence = result.sequence;
        }

        // Track max/min
        maxBalance = Math.max(maxBalance, simBalance);
        minBalance = Math.min(minBalance, simBalance);
        balanceHistory.push(simBalance);

        // Update progress every 10 rounds or if it's the last round
        if (round % 10 === 0 || round === numRounds - 1) {
          updateSimulationProgress(round + 1, numRounds);
          await new Promise(resolve => setTimeout(resolve, 1)); // Allow UI to update
        }
      }

      simulationRunning = false;
      document.getElementById('run-sim-btn').disabled = false;
      document.getElementById('stop-sim-btn').disabled = true;

      // Display results
      displaySimulationResults({
        startingBalance,
        finalBalance: simBalance,
        rounds: balanceHistory.length - 1,
        totalRounds: numRounds,
        wins,
        losses,
        totalWagered,
        maxBalance,
        minBalance,
        balanceHistory
      });
    }

    function updateSimulationProgress(current, total) {
      const percent = (current / total * 100).toFixed(1);
      document.getElementById('sim-progress-text').textContent = `${current} / ${total}`;
      document.getElementById('progress-fill').style.width = `${percent}%`;
    }

    function displaySimulationResults(results) {
      const profit = results.finalBalance - results.startingBalance;
      const profitPct = ((profit / results.startingBalance) * 100).toFixed(2);
      const winRate = results.wins + results.losses > 0 
        ? ((results.wins / (results.wins + results.losses)) * 100).toFixed(1)
        : 0;
      const drawdown = results.startingBalance - results.minBalance;

      document.getElementById('sim-final-balance').textContent = `$${results.finalBalance}`;
      document.getElementById('sim-final-balance').style.color = profit >= 0 ? '#4ade80' : '#f97373';
      document.getElementById('sim-profit-pct').textContent = `${profit >= 0 ? '+' : ''}${profitPct}%`;
      document.getElementById('sim-profit-pct').style.color = profit >= 0 ? '#4ade80' : '#f97373';
      
      document.getElementById('sim-rounds-played').textContent = results.rounds;
      document.getElementById('sim-rounds-total').textContent = results.totalRounds;
      
      document.getElementById('sim-wins').textContent = results.wins;
      document.getElementById('sim-losses').textContent = results.losses;
      document.getElementById('sim-win-rate').textContent = `${winRate}%`;
      
      document.getElementById('sim-total-wagered').textContent = `$${results.totalWagered}`;
      document.getElementById('sim-max-balance').textContent = `$${results.maxBalance}`;
      document.getElementById('sim-max-drawdown').textContent = `$${drawdown}`;

      // Draw chart
      drawBalanceChart(results.balanceHistory, results.startingBalance);

      document.getElementById('sim-results').classList.add('active');
    }

    function drawBalanceChart(balanceHistory, startingBalance) {
      const chartWidth = 800;
      const chartHeight = 180;
      const padding = 20;
      const plotWidth = chartWidth - padding * 2;
      const plotHeight = chartHeight - padding * 2;

      const maxBalance = Math.max(...balanceHistory);
      const minBalance = Math.min(...balanceHistory);
      const range = maxBalance - minBalance || 1;

      const points = balanceHistory.map((balance, index) => {
        const x = padding + (index / (balanceHistory.length - 1)) * plotWidth;
        const y = padding + plotHeight - ((balance - minBalance) / range) * plotHeight;
        return `${x},${y}`;
      }).join(' ');

      document.getElementById('balance-line').setAttribute('points', points);

      // Add starting balance line
      const startY = padding + plotHeight - ((startingBalance - minBalance) / range) * plotHeight;
      const existingStartLine = document.getElementById('start-line');
      if (existingStartLine) existingStartLine.remove();
      
      const startLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      startLine.setAttribute('id', 'start-line');
      startLine.setAttribute('class', 'chart-grid');
      startLine.setAttribute('x1', padding);
      startLine.setAttribute('y1', startY);
      startLine.setAttribute('x2', chartWidth - padding);
      startLine.setAttribute('y2', startY);
      startLine.setAttribute('stroke', 'rgba(52,211,153,0.4)');
      startLine.setAttribute('stroke-dasharray', '4,4');
      document.getElementById('balance-chart').appendChild(startLine);
    }

    function updateStrategyInfo() {
      const strategy = document.getElementById('strategy-type').value;
      const info = STRATEGIES[strategy] || '';
      document.getElementById('strategy-info').textContent = info;
    }

    // --- Event handlers ---
    // Strategy info update
    document.getElementById('strategy-type').addEventListener('change', function() {
      updateStrategyInfo();
      
      // Show/hide dual bet options
      const isDualMartingale = this.value === 'dual-martingale';
      const dualBetGroup = document.getElementById('dual-bet-group');
      const betTargetLabel = document.getElementById('bet-target-label');
      
      if (isDualMartingale) {
        dualBetGroup.style.display = 'block';
        betTargetLabel.textContent = '(Select dual bet)';
        // Auto-select first dual option
        document.getElementById('sim-bet-target').value = 'dual-dozen-1-2';
      } else {
        dualBetGroup.style.display = 'none';
        betTargetLabel.textContent = '';
        // Reset to single bet if dual was selected
        const currentTarget = document.getElementById('sim-bet-target').value;
        if (currentTarget.startsWith('dual-')) {
          document.getElementById('sim-bet-target').value = 'red';
        }
      }
      
      // Update odds hint
      const betTarget = document.getElementById('sim-bet-target').value;
      const oddsLabel = getBetOddsLabel(betTarget);
      document.getElementById('bet-odds-hint').textContent = `Pays ${oddsLabel}`;
    });

    // Bet target odds hint update
    document.getElementById('sim-bet-target').addEventListener('change', function() {
      const betTarget = this.value;
      const oddsLabel = getBetOddsLabel(betTarget);
      document.getElementById('bet-odds-hint').textContent = `Pays ${oddsLabel}`;
    });

    // Simulation controls
    document.getElementById('run-sim-btn').addEventListener('click', runSimulation);

    document.getElementById('stop-sim-btn').addEventListener('click', () => {
      simulationStopped = true;
      document.getElementById('stop-sim-btn').disabled = true;
    });

    document.getElementById('clear-sim-btn').addEventListener('click', () => {
      document.getElementById('sim-results').classList.remove('active');
      document.getElementById('sim-progress').style.display = 'none';
      document.getElementById('progress-fill').style.width = '0%';
    });

    // Chip selection
    document.querySelectorAll('.chip-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        currentChipValue = parseInt(btn.getAttribute('data-value'));
      });
    });

    clearBetsBtn.addEventListener('click', clearAllBets);

    repeatBetBtn.addEventListener('click', repeatLastBet);

    resetBtn.addEventListener("click", () => {
      balance = START_BALANCE;
      lastBalance = START_BALANCE;
      totalSpins = 0;
      redCount = 0;
      blackCount = 0;
      greenCount = 0;
      lastBet = null;

      statSpinsEl.textContent = "0";
      statRedEl.textContent = "0";
      statBlackEl.textContent = "0";
      statGreenEl.textContent = "0";
      statProfitEl.textContent = "$0";
      statProfitEl.style.color = "#e5e7eb";

      historyListEl.innerHTML = "";
      latestResultEl.innerHTML = `
        <div class="result-number">
          ‚Äì
          <span class="chip">No spins yet</span>
        </div>
        <div class="result-details">
          Place a bet and hit ‚ÄúSpin‚Äù to begin.
        </div>
      `;
      wheelCenterEl.textContent = "?";
      updateBalanceDisplay();
      errorEl.textContent = "";
    });

    spinBtn.addEventListener("click", () => {
      errorEl.textContent = "";

      const totalBetAmount = getTotalBetAmount();
      if (totalBetAmount === 0) {
        showError('Place at least one bet before spinning!');
        return;
      }

      if (totalBetAmount > balance) {
        showError('Total bets exceed your balance!');
        return;
      }

      spinBtn.disabled = true;
      resetBtn.disabled = true;
      clearBetsBtn.disabled = true;
      repeatBetBtn.disabled = true;

      // Store current bet for history
      lastBet = [...placedBets];

      animateWheelSpin(() => {
        const outcomeNumber = spinWheel();
        const totalWinnings = calculateWinnings(outcomeNumber);
        const netProfit = totalWinnings - totalBetAmount;

        balance += netProfit;

        updateStats(outcomeNumber);
        updateBalanceDisplay();
        updateLatestResult(
          outcomeNumber,
          netProfit,
          totalBetAmount,
          placedBets.length
        );
        addHistoryItem(
          outcomeNumber,
          netProfit,
          totalBetAmount
        );

        clearAllBets();
        spinBtn.disabled = false;
        resetBtn.disabled = false;
        clearBetsBtn.disabled = false;
        repeatBetBtn.disabled = false;
      });
    });

    // Keyboard support - Enter to spin
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !spinBtn.disabled) {
        spinBtn.click();
      }
    });

    // Blackjack event listeners
    document.getElementById('bj-num-decks').addEventListener('change', function() {
      bjNumDecks = parseInt(this.value);
      bjDeck = createDeck(bjNumDecks);
      updateDeckInfo();
    });

    document.getElementById('bj-reset-deck-btn').addEventListener('click', function() {
      bjDeck = createDeck(bjNumDecks);
      updateDeckInfo();
      showError('Deck shuffled!');
      setTimeout(() => errorEl.textContent = '', 2000);
    });

    document.getElementById('bj-deal-btn').addEventListener('click', function() {
      if (bjGameInProgress) {
        showError('Game in progress!');
        return;
      }
      startBlackjackGame();
    });

    document.getElementById('bj-hit-btn').addEventListener('click', playerHit);
    document.getElementById('bj-stand-btn').addEventListener('click', playerStand);
    document.getElementById('bj-double-btn').addEventListener('click', playerDouble);

    // Initial setup
    updateBalanceDisplay();
    generateRouletteTable();
    updateBetDisplay();
    updateStrategyInfo();
    
    // Set initial odds hint
    const initialBetTarget = document.getElementById('sim-bet-target').value;
    document.getElementById('bet-odds-hint').textContent = `Pays ${getBetOddsLabel(initialBetTarget)}`;
    
    // Initialize Blackjack
    bjDeck = createDeck(bjNumDecks);
    updateDeckInfo();
  </script>
</body>
</html>
